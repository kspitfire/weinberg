Несколько лет назад, во времена, когда язык COBOL казался большой и белой надеждой всего программирования, было много разговоров о возможности руководства читать код программ. С высоты нынешних лет мы видим, что эта идея едва ли затронула хоть сколько-нибудь значимую часть руководства, надеявшихся освободиться от зависимости от своих программистов. Никто не смог всерьёз поверить в то, что они будут этим заниматься. Да и зачем им это? Даже сами программисты _не читают_ своих программ.

Но разве чтение программ - это не прерогатива исключительно вычислительных машин? Разве не для них они написаны? И да и нет. Даже если нам не нужно заботиться о её модификации и работы с другими программами, чтение программного кода - это не такая уж и плохая идея с точки зрения изучения программирования.

Программирование, помимо всего прочего - это своего рода письменность. Один из способов изучить письменность - это, собственно, писать, но чтение также этому способствует. Мы читаем примеры, как хорошие, так и плохие, чтобы лучше понять письменность, привыкнуть к ней и изучить её. Но сколько программистов учатся писать код, читая программы? Такие есть, но их немного. А с появлением терминалов дела пошли ещё хуже, так как программисты даже не видят кода _своих_ программ в удобном для восприятия виде. В прежние времена - которые, по меркам истории вычислительных процессов, были не так давно - доступ к ЭВМ был куда сложнее и программисты просто не могли себе позволить учиться писать код во время запусков своих программ. Ситуация была порой настолько плоха, что программисты проводили уйму времени, читая код программ друг у друга. Некоторые даже ходили читать код в программные библиотеки, которые в те времена были библиотеками в традиционном понимании этого слова.

Но, увы, времена изменились. Как и телевидение, заменившее некогда собой удовольствие от чтения книг и сделавшего это занятие старомодным для молодежи, появление терминалов, да и в целом изменившаяся обстановка в сфере программирования превратила чтение программ в признак безнадежно отсталого программиста. Пока поседевший олдскульный программист коротает ночи со своими любимыми подпрограммами и макросами, молодое поколение уже вовсю вовлечено в диалог с терминалом. Нет никаких сомнений в том, что вести диалог с гигантской вычислительной машиной куда более захватывающе, нежели тихо разглядывать работу других. Однако разумнее ли?

Одного молодого писателя наших времен однажды спросили о его любимых авторах. В ответ он сказал, что он вообще никого не читает, поскольку его идеи настолько новы и превосходны, что читать кого-то ещё помимо него было бы просто потерей времени. Как вы, наверное, и ожидали, его романы "слегка" не соответствовали таким заявлениям. Возможно то же можно сказат и о наших молодых и радикально настроенных программистах. Наверное, есть кое-что, что можно почерпнуть, читая чужой код - и если бы это были только насмешки, порожденные плохими примерами. Вероятно, если мы действительно хотим узнать _как_ программисты пишут код - чтобы приподнять вуаль мистики и загадочности - мы должны извлечь как можно больше информации из чтения чужого кода.

### Пример
Чтобы продемонстрировать все преимущества от чтения программного кода, давайте рассмотрим небольшой пример жизни одной маленькой програмки - одной из многих тысяч. Её код на языке PL/1 представлен в Листинге 1.1. Что мы можем из него узнать?

```
XXX: PROCEDURE OPTIONS(MAIN);
     DECLARE B(1000) FIXED(7,2),
             C FIXED(11,2),
             (I, J) FIXED BINARY;

    C = 0;
    DO I = 1 TO 10;
        GET LIST((B(J) DO J = 1 TO 1000));
        DO J = 1 TO 1000;
           C = C + B(J);
           END;
        END;
    PUT LIST('SUM IS ', C);
    END XXX;
```
Листинг 1.1. Программа для чтения.

Для начала нам нужно определиться с самим подходом к чтению кода, которое, в отличие от чтения романов, далеко не всегда целесообразно делать от начала до конца. Оно также не похоже на чтение детективов, где можно пролистать на предпоследнюю страницу в поисках интересной развязки, или чтение популярных библиотечных книжек, которые можно открыть на самых мятых страничках, чтобы вычитать самые вкусные места. Нет, избранные места программного кода не располагаются в каких-то заранее заготовленных местах, хотя, как мы увидим далее, мы можем всё же определять его ключевые фрагменты при отладке или оптимизации.

Вместо всего этого при чтении программного кода мы должны опираться на некоторую логическую модель, содержащую _причины_ появления каждой написанной строчки программного кода. Другими словами, когда мы смотрим на каждый отдельный фрагмент кода, мы должны спрашивать себя "почему этот фрагмент здесь находится?"

###Машинные ограничения
Одна из причин, объясняющих существование каких-то фрагментов кода - это ограниченность реальной вычислительной машины, которая будет запускать код, по сравнению с некоторой идеальной машиной, способной решить ту же поставленную задачу. В нашем примере мы видим, что всего программой считано и просуммировано 10 000 чисел, однако они считаны порциями по тысяче. Так как числа представлены в виде списка языка PL/1, то нет никакой причины делить его на такие порции, кроме той, что память ЭВМ ограничена и все 10 000 чисел не могут быть сохранены в ней одновременно. Другими словами, не имея 40 000  доступных байт, программист вынужден был разбить весь список на порции, что привело к появлению дополнительного цикла. Если бы у него была возможность сохранить в памяти сразу все 10 000 чисел, он мог бы написать программу, подобную той, что представлена в Листинге 1.2.

```
XXX: PROCEDURE OPTIONS(MAIN);
     DECLARE A(10000) FIXED(7,2),
             C FIXED(11,2),
             J FIXED BINARY;

    C = 0;
    GET LIST((A(J) DO J = 1 TO 10000));
    DO J = 1 TO 10000;
        C = C + A(J);
        END;
    PUT LIST('SUM IS ', C);
    END XXX;
```
Листинг 1.2. Пример без ограничений по памяти.